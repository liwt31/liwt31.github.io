<!DOCTYPE html>













<html class="theme-next mist" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.4.2',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="IntroQuicksort is quick, and it’s well known that it can be defeated under certain circumstances, from the simplest already sorted data, to the killer adversary. But if someone claims he has found ano">
<meta property="og:type" content="article">
<meta property="og:title" content="Mergesort is faster than Quicksort">
<meta property="og:url" content="https://liwt31.github.io/2018/11/20/fast_merge/index.html">
<meta property="og:site_name" content="Weitang Li&#39;s blog">
<meta property="og:description" content="IntroQuicksort is quick, and it’s well known that it can be defeated under certain circumstances, from the simplest already sorted data, to the killer adversary. But if someone claims he has found ano">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://user-images.githubusercontent.com/22628546/48837876-858ecf00-edc1-11e8-8142-d2dd9c03d8f0.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/22628546/48828767-96344a80-edab-11e8-9904-674efa3ccec4.png">
<meta property="og:updated_time" content="2019-03-05T12:34:52.523Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mergesort is faster than Quicksort">
<meta name="twitter:description" content="IntroQuicksort is quick, and it’s well known that it can be defeated under certain circumstances, from the simplest already sorted data, to the killer adversary. But if someone claims he has found ano">
<meta name="twitter:image" content="https://user-images.githubusercontent.com/22628546/48837876-858ecf00-edc1-11e8-8142-d2dd9c03d8f0.png">






  <link rel="canonical" href="https://liwt31.github.io/2018/11/20/fast_merge/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Mergesort is faster than Quicksort | Weitang Li's blog</title>
  




<script async src="https://www.googletagmanager.com/gtag/js?id=UA-112074287-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-112074287-1');
</script>



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?bf4c5f63e0485106a91950fc4aa87838";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Weitang Li's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">We've havered enough. Let's get tae work!</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />About</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://liwt31.github.io/2018/11/20/fast_merge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Weitang Li">
      <meta itemprop="description" content="Weitang Li's blog">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Weitang Li's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Mergesort is faster than Quicksort
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-11-20 20:29:43" itemprop="dateCreated datePublished" datetime="2018-11-20T20:29:43+08:00">2018-11-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-05 20:34:52" itemprop="dateModified" datetime="2019-03-05T20:34:52+08:00">2019-03-05</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>Quicksort is quick, and it’s well known that it can be defeated under certain circumstances, from the simplest already sorted data, to the <a href="https://www.cs.dartmouth.edu/~doug/mdmspe.pdf" target="_blank" rel="noopener">killer adversary</a>. But if someone claims he has found another algorithm that can outperform Quicksort in random array without strong constraint on the data to be sorted, you’d probably disdain for it and think he must get something wrong. At least, that’s what I would do before my recent discovery - <strong>Mergesort is faster than Quicksort, if you use GCC and your CPU is somewhat “new”</strong>.</p>
<p>Ridiculous, right? If you don’t believe me, have a look at <a href="https://colab.research.google.com/drive/1jzTEXauoPq8lFedGZgUpH3DaJht2ctrK" target="_blank" rel="noopener">this Google Colab notebook</a>:<br><img src="https://user-images.githubusercontent.com/22628546/48837876-858ecf00-edc1-11e8-8142-d2dd9c03d8f0.png" alt="notebook"><br><a id="more"></a></p>
<p>It appears on the Google platform, with the <code>NumPy 1.14.6</code> implementation, for a \(10^6\) sized int64 random array, Mergesort is faster than Quicksort, or the timing module of IPython is wrong.<br>Is this a bug? Is this particular? Well, you can do a quick benchmark with the following code on your machine (preferably with the same NumPy version in the notebook):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">print(np.__version__)</span><br><span class="line"></span><br><span class="line">size = <span class="number">10</span> ** <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">benchmark</span><span class="params">(kind)</span>:</span></span><br><span class="line">    a = np.random.randint(<span class="number">0</span>, size, size)</span><br><span class="line">    times = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        b = a.copy()</span><br><span class="line">        time1 = time.time()</span><br><span class="line">        b.sort(kind=kind)</span><br><span class="line">        times.append(time.time() - time1)</span><br><span class="line">    <span class="keyword">return</span> np.array(times)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> kind <span class="keyword">in</span> [<span class="string">"quicksort"</span>, <span class="string">"mergesort"</span>]:</span><br><span class="line">    times = benchmark(kind) * <span class="number">10</span> ** <span class="number">6</span>  <span class="comment"># use usec as unit</span></span><br><span class="line">    print(<span class="string">"&#123;&#125;: &#123;:.0f&#125;±&#123;:.0f&#125; usec"</span>.format(kind, times.mean(), times.std()))</span><br></pre></td></tr></table></figure></p>
<p>The output on my machine is:<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.15</span><span class="number">.2</span></span><br><span class="line"><span class="symbol">quicksort:</span> <span class="number">7407</span>±<span class="number">640</span> usec</span><br><span class="line"><span class="symbol">mergesort:</span> <span class="number">5923</span>±<span class="number">691</span> usec</span><br></pre></td></tr></table></figure></p>
<p>As we shall see later, the result is CPU and compiler dependent. So if you get the same result, let’s delve into it to see what really happens, and if not, the remaining of this post will still make sense to you, and in the end of the post you’ll have a clear idea how to make Mergesort beat Quicksort on your computer.</p>
<h1 id="Get-rid-of-NumPy"><a href="#Get-rid-of-NumPy" class="headerlink" title="Get rid of NumPy"></a>Get rid of NumPy</h1><p>At this point it is quite natural to think that the abnormal result is related to NumPy because it’s a huge project and lots of places can behave unexpectedly. In fact, <a href="https://docs.scipy.org/doc/numpy-1.15.4/reference/generated/numpy.sort.html#numpy.sort" target="_blank" rel="noopener">at later version the Quicksort implementation in NumPy is actually Introsort</a>, which transforms Quicksort to Heapsort if the worst case scenario of Quicksort seems approaching.<br>At first I think this is the origin of the slower Quicksort. The inference is easy to validate (or invalidate) by writing some home-brew sort code. This is easy. Quicksort and Mergesort are both very fundamental algorithms and appear in every algorithm course or textbook. Below is the code, almost couldn’t be simpler:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">int64_quick_sort</span><span class="params">(<span class="keyword">int64_t</span> *dst, <span class="keyword">const</span> <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> *pl, *pr, *pm, pivot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">16</span>) &#123;</span><br><span class="line">        int64_insertion_sort(dst, size);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pl = dst;</span><br><span class="line">    pr = pl + size;</span><br><span class="line">    pm = pl + ((pr - pl) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    --pr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* median of 3 */</span></span><br><span class="line">    <span class="keyword">if</span> (*pm &lt; *pl) &#123;</span><br><span class="line">        SORT_SWAP(*pm, *pl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*pr &lt; *pm) &#123;</span><br><span class="line">        SORT_SWAP(*pr, *pm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*pm &lt; *pl) &#123;</span><br><span class="line">        SORT_SWAP(*pm, *pl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SORT_SWAP(*pl, *pm);</span><br><span class="line">    pivot = *pl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123; --pr; &#125;</span><br><span class="line">        <span class="keyword">while</span> (pivot &lt; *pr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pr &lt;= pl) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SORT_SWAP(*pl, *pr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123; ++pl; &#125;</span><br><span class="line">        <span class="keyword">while</span> (*pl &lt; pivot);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pr &lt;= pl) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SORT_SWAP(*pl, *pr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *pl = pivot;</span><br><span class="line">    int64_quick_sort(dst, pl - dst);</span><br><span class="line">    int64_quick_sort(pl + <span class="number">1</span>, dst + size - pl - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">int64_merge_sort_rec</span><span class="params">(<span class="keyword">int64_t</span> *dst, <span class="keyword">const</span> <span class="keyword">size_t</span> size, <span class="keyword">int64_t</span> *pw)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> *pl, *pr, *pm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">16</span>) &#123;</span><br><span class="line">        int64_insertion_sort(dst, size);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pl = dst;</span><br><span class="line">    pr = pl + size;</span><br><span class="line">    pm = pl + ((pr - pl) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    int64_merge_sort_rec(pl, pm - pl, pw);</span><br><span class="line">    int64_merge_sort_rec(pm, pr - pm, pw);</span><br><span class="line">    <span class="built_in">memcpy</span>(pw, pl, (pm - pl) * <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pm &lt; pr &amp;&amp; pl &lt; pm) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*pw &lt;= *pm) &#123;</span><br><span class="line">            *pl++ = *pw++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *pl++ = *pm++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pl &lt; pm) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(pl, pw, (pm - pl)*<span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">int64_merge_sort</span><span class="params">(<span class="keyword">int64_t</span> *dst, <span class="keyword">const</span> <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> *pw;</span><br><span class="line"></span><br><span class="line">    pw = (<span class="keyword">int64_t</span> *) <span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>));</span><br><span class="line">    int64_merge_sort_rec(dst, size, pw);</span><br><span class="line">    <span class="built_in">free</span>(pw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/liwt31/fast_mergesort" target="_blank" rel="noopener">Integrate this code with some benchmark framework</a>, I’m able to produce the following output:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cc -O3 -g -Wall -pedantic main<span class="selector-class">.c</span> -o fast_merge.out</span><br><span class="line">./fast_merge.out</span><br><span class="line">int64_quick_sort              - ok,    <span class="number">25683.0</span> usec</span><br><span class="line">int64_merge_sort              - ok,    <span class="number">19178.0</span> usec</span><br><span class="line">float64_quick_sort            - ok,    <span class="number">28916.0</span> usec</span><br><span class="line">float64_merge_sort            - ok,    <span class="number">27397.0</span> usec</span><br></pre></td></tr></table></figure></p>
<p>Surprised, huh? You can double-check again there’s nothing fishy in the source code of the benchmark suite or both algorithms. Again, the result is platform and compiler dependent, so if you can’t reproduce this result, don’t worry, you’ll know why at the end of the post.</p>
<h1 id="CPU-and-Compiler"><a href="#CPU-and-Compiler" class="headerlink" title="CPU and Compiler"></a>CPU and Compiler</h1><p>I soon find out that CPU (or more broadly platform) and compiler have an impact on the benchmark result. For the same binary executable, different CPU lead to different conclusion. Below is a little summary of platforms I tested:</p>
<table>
<thead>
<tr>
<th>CPU type</th>
<th>Launch Date</th>
<th>Faster int</th>
<th>Faster float</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>E5-2620</td>
<td>Q1’12</td>
<td>Mergesort</td>
<td>Quicksort</td>
<td></td>
</tr>
<tr>
<td>E5-2620 v2</td>
<td>Q3’13</td>
<td>Mergesort</td>
<td>The same</td>
<td></td>
</tr>
<tr>
<td>i7-4790k</td>
<td>Q2’14</td>
<td>Mergesort</td>
<td>Quicksort</td>
<td></td>
</tr>
<tr>
<td>E5-2630 v3</td>
<td>Q3’14</td>
<td>Mergesort</td>
<td>Quicksort</td>
<td></td>
</tr>
<tr>
<td>E5-2640 v3</td>
<td>Q3’14</td>
<td>Mergesort</td>
<td>Quicksort</td>
<td></td>
</tr>
<tr>
<td>i7-6700HQ</td>
<td>Q3’15</td>
<td>Mergesort</td>
<td>Mergesort</td>
<td>My PC</td>
</tr>
<tr>
<td>E5-2676 v3</td>
<td>Q4’15</td>
<td>Mergesort</td>
<td>The same</td>
<td>Amazon vps</td>
</tr>
<tr>
<td>E5-2680 v4</td>
<td>Q1’16</td>
<td>Mergesort</td>
<td>Mergesort</td>
<td></td>
</tr>
<tr>
<td>E5-26xx v4</td>
<td>Q?’16</td>
<td>Mergesort</td>
<td>Mergesort</td>
<td>Tencent vps</td>
</tr>
<tr>
<td>Silver 4116</td>
<td>Q3’17</td>
<td>Mergesort</td>
<td>Mergesort</td>
<td></td>
</tr>
<tr>
<td>Unknown Xeon</td>
<td>?</td>
<td>Mergesort</td>
<td>Mergesort</td>
<td><a href="https://console.cloud.google.com/cloudshell" target="_blank" rel="noopener">Google cloud console</a></td>
</tr>
</tbody>
</table>
<p>It seems with newer CPU Mergesort performs better on float sort, indicating that the reason why Mergesort is faster lays in the assembly code level.<br>Another strong evidence indicating the assembly code matters is the compiler dependency. If Clang is used as the compiler, the world we’re familiar with comes back again:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">clang -O3 -g -Wall -pedantic main<span class="selector-class">.c</span> -o fast_merge.out</span><br><span class="line">./fast_merge.out</span><br><span class="line">int64_quick_sort              - ok,    <span class="number">25017.0</span> usec</span><br><span class="line">int64_merge_sort              - ok,    <span class="number">29115.0</span> usec</span><br><span class="line">float64_quick_sort            - ok,    <span class="number">27895.0</span> usec</span><br><span class="line">float64_merge_sort            - ok,    <span class="number">32559.0</span> usec</span><br></pre></td></tr></table></figure></p>
<p>Quicksort becomes the best! Combined with previous GCC result, the mist around super-fast Mergesort becomes thinner:</p>
<p><img src="https://user-images.githubusercontent.com/22628546/48828767-96344a80-edab-11e8-9904-674efa3ccec4.png" alt="fast"></p>
<p>GCC must have done some genius optimization on the Mergesort code that greatly boost the speed, meanwhile Clang is not able to do so. So the difference between the binary code generated between GCC and Clang is our key to answer why Mergesort is faster.</p>
<h1 id="Disassembly"><a href="#Disassembly" class="headerlink" title="Disassembly"></a>Disassembly</h1><p>There are tons of assembly code out there and we should only focus on the most important part, that is, those corresponding to the following C code:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (pm &lt; pr &amp;&amp; pl &lt; pm) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*pw &lt;= *pm) &#123;</span><br><span class="line">        *pl++ = *pw++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *pl++ = *pm++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Because this is where the merging process, the heaviest work, takes place. The code is not hard to understand, plain usual Mergesort routine. <code>pl</code>, <code>pm</code> and <code>pr</code> points at the left side, middle and right side of the array respectively, while <code>pw</code> points to the buffer to which the left part of the array has already been copied. First let’s look at the code generated by Clang for sorting int64:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">0x4009f0 &lt;int64_merge_sort_rec+224&gt;     mov    (%r14),%rax </span><br><span class="line">0x4009f3 &lt;int64_merge_sort_rec+227&gt;     mov    (%r15),%rsi </span><br><span class="line">0x4009f6 &lt;int64_merge_sort_rec+230&gt;     cmp    %rsi,%rax   ;compare *pw and *pm</span><br><span class="line">0x4009f9 &lt;int64_merge_sort_rec+233&gt;     jle    0x400a1e &lt;int64_merge_sort_rec+270&gt;</span><br><span class="line">0x4009fb &lt;int64_merge_sort_rec+235&gt;     lea    0x8(%r15),%rdx   ;the else branch</span><br><span class="line">0x4009ff &lt;int64_merge_sort_rec+239&gt;     lea    0x8(%rbx),%rcx </span><br><span class="line">0x400a03 &lt;int64_merge_sort_rec+243&gt;     mov    %rsi,(%rbx) </span><br><span class="line">0x400a06 &lt;int64_merge_sort_rec+246&gt;     cmp    %r15,%rbx   </span><br><span class="line">0x400a09 &lt;int64_merge_sort_rec+249&gt;     setb   %al   </span><br><span class="line">0x400a0c &lt;int64_merge_sort_rec+252&gt;     cmp    %rbp,%rdx   </span><br><span class="line">0x400a0f &lt;int64_merge_sort_rec+255&gt;     jae    0x400a3b &lt;int64_merge_sort_rec+299&gt;    </span><br><span class="line">0x400a11 &lt;int64_merge_sort_rec+257&gt;     cmp    %r15,%rbx   </span><br><span class="line">0x400a14 &lt;int64_merge_sort_rec+260&gt;     mov    %rdx,%r15   </span><br><span class="line">0x400a17 &lt;int64_merge_sort_rec+263&gt;     mov    %rcx,%rbx   </span><br><span class="line">0x400a1a &lt;int64_merge_sort_rec+266&gt;     jb     0x4009f0 &lt;int64_merge_sort_rec+224&gt;    </span><br><span class="line">0x400a1c &lt;int64_merge_sort_rec+268&gt;     jmp    0x400a3b &lt;int64_merge_sort_rec+299&gt;    </span><br><span class="line">0x400a1e &lt;int64_merge_sort_rec+270&gt;     add    $0x8,%r14   ;the *pw &lt;= *pm branch</span><br><span class="line">0x400a22 &lt;int64_merge_sort_rec+274&gt;     mov    %rax,(%rbx) </span><br><span class="line">0x400a25 &lt;int64_merge_sort_rec+277&gt;     add    $0x8,%rbx   </span><br><span class="line">0x400a29 &lt;int64_merge_sort_rec+281&gt;     cmp    %r15,%rbx   </span><br><span class="line">0x400a2c &lt;int64_merge_sort_rec+284&gt;     setb   %al   </span><br><span class="line">0x400a2f &lt;int64_merge_sort_rec+287&gt;     cmp    %rbp,%r15   </span><br><span class="line">0x400a32 &lt;int64_merge_sort_rec+290&gt;     jae    0x400a41 &lt;int64_merge_sort_rec+305&gt;    </span><br><span class="line">0x400a34 &lt;int64_merge_sort_rec+292&gt;     cmp    %r15,%rbx   </span><br><span class="line">0x400a37 &lt;int64_merge_sort_rec+295&gt;     jb     0x4009f0 &lt;int64_merge_sort_rec+224&gt;</span><br></pre></td></tr></table></figure></p>
<p>There isn’t much optimization in this code actually, merely a “machine translation” of C code. Note that <strong>two branches</strong> appear in this assembly code, decided by <code>&lt;int64_merge_sort_rec+233&gt;</code>, corresponding to <code>if (*pw &lt;= *pm)</code> in C code.<br>So, what about the code GCC generated? The first impression it gives me is <em>short</em>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0x4009b0 &lt;int64_merge_sort_rec+256&gt;     cmp    %rbx,%rbp      </span><br><span class="line">0x4009b3 &lt;int64_merge_sort_rec+259&gt;     jae    0x4009e4 &lt;int64_merge_sort_rec+308&gt; </span><br><span class="line">0x4009b5 &lt;int64_merge_sort_rec+261&gt;     mov    (%r12),%rax    </span><br><span class="line">0x4009b9 &lt;int64_merge_sort_rec+265&gt;     mov    (%rbx),%rdx    </span><br><span class="line">0x4009bc &lt;int64_merge_sort_rec+268&gt;     lea    0x8(%r12),%rsi </span><br><span class="line">0x4009c1 &lt;int64_merge_sort_rec+273&gt;     lea    0x8(%rbx),%rcx </span><br><span class="line">0x4009c5 &lt;int64_merge_sort_rec+277&gt;     cmp    %rdx,%rax      </span><br><span class="line">0x4009c8 &lt;int64_merge_sort_rec+280&gt;     cmovle %rsi,%r12      </span><br><span class="line">0x4009cc &lt;int64_merge_sort_rec+284&gt;     add    $0x8,%rbp      </span><br><span class="line">0x4009d0 &lt;int64_merge_sort_rec+288&gt;     cmp    %rdx,%rax      </span><br><span class="line">0x4009d3 &lt;int64_merge_sort_rec+291&gt;     cmovg  %rcx,%rbx      </span><br><span class="line">0x4009d7 &lt;int64_merge_sort_rec+295&gt;     cmovg  %rdx,%rax      </span><br><span class="line">0x4009db &lt;int64_merge_sort_rec+299&gt;     cmp    %rbx,%r13      </span><br><span class="line">0x4009de &lt;int64_merge_sort_rec+302&gt;     mov    %rax,-0x8(%rbp)</span><br><span class="line">0x4009e2 &lt;int64_merge_sort_rec+306&gt;     ja     0x4009b0 &lt;int64_merge_sort_rec+256&gt;</span><br></pre></td></tr></table></figure></p>
<p>Without further digging you can tell from the length that this must be very efficient, but let’s dig deeper into this and see what magic GCC has done. </p>
<ol>
<li><code>%rbx</code> and <code>%rbp</code> represent <code>pm</code> and <code>pl</code> respectively. If they become equal, then break the loop, otherwise continue. </li>
<li>The values in address <code>%r12</code> (<code>pw</code>) and <code>%rbx</code> (<code>pm</code>) are then moved to <code>%rax</code> and <code>%rdx</code>.</li>
<li><code>%rax</code> and <code>%rdx</code> are compared <strong>twice</strong> in <code>&lt;int64_merge_sort_rec+277&gt;</code> and <code>&lt;int64_merge_sort_rec+288&gt;</code> to decide if <code>%r12</code> (<code>pw</code>) and <code>%rbx</code> (<code>pm</code>) really need to self-increase. </li>
<li>The smaller of <code>%rdx</code> (<code>*pm</code>) and <code>%rax</code> (<code>*pw</code>) is stored to <code>%rax</code> (<code>&lt;int64_merge_sort_rec+295&gt;</code>) and then moved to <code>*pl</code> (<code>&lt;int64_merge_sort_rec+302&gt;</code>). </li>
<li><code>%rbx</code> (<code>pm</code>) is at last compared with <code>%r13</code> (<code>pr</code>) as another condition to decide whether break the loop or start from the beginning. </li>
</ol>
<p>Note that there is <strong>only one branch</strong> and only two <strong>highly predictable</strong> jump instructions in the control flow. This pattern can make CPU pipeline work at maximum power. The price is multiple comparison between <code>*pw</code> and <code>*pm</code>, which isn’t really a big deal for int64. What a bargain!</p>
<blockquote>
<p>Interested reader can compare length, number of branches as well as predictability of jump instructions between GCC compiled Mergesort and Quicksort, then it may become much reasonable why Mergesort can be faster than Quicksort. In fact, <code>perf stats</code> indicates that Quicksort has 15% branch-miss while Mergesort has only 3%.</p>
</blockquote>
<p>Now that it becomes clear why GCC compiled binary is much faster than Clang compiled binary, how about the relation between the speed of float number sorting and CPU release date? Why does newer CPU do better in Mergesort for float number? Well, I’m not an expert on CPU architecture and performance, but I guess the reason is that comparing float number used to be expensive but it keeps getting cheaper and cheaper over days. Hence old CPU suffer from multiple float number comparison, whereas for new CPU comparison of float is as cheap as comparison of integer.</p>
<h1 id="How-to-make-Mergesort-faster-than-Quicksort"><a href="#How-to-make-Mergesort-faster-than-Quicksort" class="headerlink" title="How to make Mergesort faster than Quicksort"></a>How to make Mergesort faster than Quicksort</h1><p>If you’ve tested my benchmark code in your environment and Quicksort is still invincible, basically you need to check two things:</p>
<ul>
<li>Is your CPU too old? If it’s 10 years old well you’d better get a new one.</li>
<li>Is the assembly code generated by your compiler “optimized” for Mergesort? My test environment includes GCC 5.4.0 (Ubuntu 16.04 default) and GCC 4.8.5 (Centos 7 default) so these two versions should be OK. My preliminary result on Windows shows that no compiler on the platform including <code>vc</code> can do the optimization.<br><strong>If all compilers fail on your machine or you’re simply not interested in disassembly, you can checkout the inline-assembly version of Mergesort in <a href="https://github.com/liwt31/fast_mergesort" target="_blank" rel="noopener">this repo</a></strong>, which yields compiler-independent optimized Mergesort code.</li>
</ul>
<p>A convenient way for you to avoid buying a new CPU or setting up lots of compilers is to use the <a href="https://console.cloud.google.com/cloudshell" target="_blank" rel="noopener">Google cloud console</a>. Try:<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/liwt31/fast_mergesort.git</span><br><span class="line">cd fast_mergesort/bin</span><br><span class="line">./fast_merge.out</span><br></pre></td></tr></table></figure></p>
<p><code>fast_merge.out</code> is a compiled binary with optimized Mergesort. You’d probably see a result saying Mergesort is faster than Quicksort like this:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">int64_quick_sort</span>              <span class="selector-tag">-</span> <span class="selector-tag">ok</span>,    30958<span class="selector-class">.0</span> <span class="selector-tag">usec</span></span><br><span class="line"><span class="selector-tag">int64_merge_sort</span>              <span class="selector-tag">-</span> <span class="selector-tag">ok</span>,    23785<span class="selector-class">.0</span> <span class="selector-tag">usec</span></span><br><span class="line"><span class="selector-tag">float64_quick_sort</span>            <span class="selector-tag">-</span> <span class="selector-tag">ok</span>,    33966<span class="selector-class">.0</span> <span class="selector-tag">usec</span></span><br><span class="line"><span class="selector-tag">float64_merge_sort</span>            <span class="selector-tag">-</span> <span class="selector-tag">ok</span>,    27837<span class="selector-class">.0</span> <span class="selector-tag">usec</span></span><br></pre></td></tr></table></figure></p>
<p>You can also compile and run for yourself:<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">make <span class="keyword">run</span><span class="bash"></span></span><br></pre></td></tr></table></figure></p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>Mergesort is faster than Quicksort, with modern CPU and a genius compiler.</p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/10/31/travis-debug/" rel="next" title="本地调试Travis-CI错误">
                <i class="fa fa-chevron-left"></i> 本地调试Travis-CI错误
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/25/seterr/" rel="prev" title="珍爱生命，使用numpy.seterr">
                珍爱生命，使用numpy.seterr <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Weitang Li</p>
              <p class="site-description motion-element" itemprop="description">Weitang Li's blog</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">29</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/liwt31" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:liwt31@163.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Intro"><span class="nav-number">1.</span> <span class="nav-text">Intro</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Get-rid-of-NumPy"><span class="nav-number">2.</span> <span class="nav-text">Get rid of NumPy</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CPU-and-Compiler"><span class="nav-number">3.</span> <span class="nav-text">CPU and Compiler</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Disassembly"><span class="nav-number">4.</span> <span class="nav-text">Disassembly</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#How-to-make-Mergesort-faster-than-Quicksort"><span class="nav-number">5.</span> <span class="nav-text">How to make Mergesort faster than Quicksort</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Conclusion"><span class="nav-number">6.</span> <span class="nav-text">Conclusion</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Weitang Li</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.4.4</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Mist</a> v6.4.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  










  





  

  

  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    
  


  
  

  

  

  

  

  

</body>
</html>
