<!DOCTYPE html>













<html class="theme-next mist" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.4.2',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="对Timsort的简介请见Wiki或者Tim本人的小文章，本文主要分析CPython（版本3.7）的实现部分，不对原理做具体介绍。Timsort的代码位于Objects/listobject.c中，大概从1000行到2000行，占据整个list实现的三分之一。本文把所有的Timsort源码基本上都粘贴过来了，所以也不会短。这段代码看起来其实很有意思，因为注释得比较详尽，画风稳中带皮，不失为消遣娱乐">
<meta property="og:type" content="article">
<meta property="og:title" content="CPython源码阅读——Timsort">
<meta property="og:url" content="https://liwt31.github.io/2018/10/27/timsort/index.html">
<meta property="og:site_name" content="Weitang Li&#39;s blog">
<meta property="og:description" content="对Timsort的简介请见Wiki或者Tim本人的小文章，本文主要分析CPython（版本3.7）的实现部分，不对原理做具体介绍。Timsort的代码位于Objects/listobject.c中，大概从1000行到2000行，占据整个list实现的三分之一。本文把所有的Timsort源码基本上都粘贴过来了，所以也不会短。这段代码看起来其实很有意思，因为注释得比较详尽，画风稳中带皮，不失为消遣娱乐">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-02-21T14:21:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CPython源码阅读——Timsort">
<meta name="twitter:description" content="对Timsort的简介请见Wiki或者Tim本人的小文章，本文主要分析CPython（版本3.7）的实现部分，不对原理做具体介绍。Timsort的代码位于Objects/listobject.c中，大概从1000行到2000行，占据整个list实现的三分之一。本文把所有的Timsort源码基本上都粘贴过来了，所以也不会短。这段代码看起来其实很有意思，因为注释得比较详尽，画风稳中带皮，不失为消遣娱乐">






  <link rel="canonical" href="https://liwt31.github.io/2018/10/27/timsort/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>CPython源码阅读——Timsort | Weitang Li's blog</title>
  




<script async src="https://www.googletagmanager.com/gtag/js?id=UA-112074287-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-112074287-1');
</script>



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?bf4c5f63e0485106a91950fc4aa87838";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Weitang Li's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">We've havered enough. Let's get tae work!</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />About</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://liwt31.github.io/2018/10/27/timsort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Weitang Li">
      <meta itemprop="description" content="Weitang Li's blog">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Weitang Li's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">CPython源码阅读——Timsort
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-10-27 20:56:19" itemprop="dateCreated datePublished" datetime="2018-10-27T20:56:19+08:00">2018-10-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-21 22:21:00" itemprop="dateModified" datetime="2019-02-21T22:21:00+08:00">2019-02-21</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>对Timsort的简介请见<a href="https://en.wikipedia.org/wiki/Timsort" target="_blank" rel="noopener">Wiki</a>或者<a href="https://svn.python.org/projects/python/trunk/Objects/listsort.txt" target="_blank" rel="noopener">Tim本人的小文章</a>，本文主要分析CPython（版本3.7）的实现部分，不对原理做具体介绍。<br>Timsort的代码位于<a href="https://github.com/python/cpython/blob/3.7/Objects/listobject.c" target="_blank" rel="noopener">Objects/listobject.c</a>中，大概从1000行到2000行，占据整个list实现的三分之一。本文把所有的Timsort源码基本上都粘贴过来了，所以也不会短。<br>这段代码看起来其实很有意思，因为注释得比较详尽，画风稳中带皮，不失为消遣娱乐之佳品。有人说CPython这部分代码很难懂，我实在不能苟同。</p>
<a id="more"></a>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Lots of code for an adaptive, stable, natural mergesort.  There are many</span></span><br><span class="line"><span class="comment"> * pieces to this algorithm; read listsort.txt for overviews and details.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* A sortslice contains a pointer to an array of keys and a pointer to</span></span><br><span class="line"><span class="comment"> * an array of corresponding values.  In other words, keys[i]</span></span><br><span class="line"><span class="comment"> * corresponds with values[i].  If values == NULL, then the keys are</span></span><br><span class="line"><span class="comment"> * also the values.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Several convenience routines are provided here, so that keys and</span></span><br><span class="line"><span class="comment"> * values are always moved in sync.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject **keys;</span><br><span class="line">    PyObject **values;</span><br><span class="line">&#125; sortslice;</span><br></pre></td></tr></table></figure>
<p>起手式先搞了一个叫做<code>sortslice</code>的结构，后面用到的非常多。这个结构粗看起来让人摸不着头脑，好好的list哪来的成对的<code>value</code>和<code>key</code>呢？看到后面会明白这是由<a href="https://docs.python.org/3/library/stdtypes.html#list.sort" target="_blank" rel="noopener">Python排序函数的原型</a>决定的。Python的排序有个叫做<code>key</code>的关键字，允许你传入一个函数然后依据这个函数来比较list中元素的大小。在CPython内部实现上如果定义了<code>key</code>那么CPython就会首先依据<code>key</code>这个函数把list中所有元素（称作<code>value</code>）的<code>key</code>都算出来，然后再依据<code>key</code>排序，这就自然出现了成对的<code>key</code>和<code>value</code>，两者在排序时要一起移动。所以<code>sortslice</code>是CPython特有的一个排序的基本单元，构成了一个run的基础。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Py_LOCAL_INLINE(<span class="keyword">void</span>)</span><br><span class="line">sortslice_copy(sortslice *s1, Py_ssize_t i, sortslice *s2, Py_ssize_t j)</span><br><span class="line">&#123;</span><br><span class="line">    s1-&gt;keys[i] = s2-&gt;keys[j];</span><br><span class="line">    <span class="keyword">if</span> (s1-&gt;values != <span class="literal">NULL</span>)</span><br><span class="line">        s1-&gt;values[i] = s2-&gt;values[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Py_LOCAL_INLINE(<span class="keyword">void</span>)</span><br><span class="line">sortslice_copy_incr(sortslice *dst, sortslice *src)</span><br><span class="line">&#123;</span><br><span class="line">    *dst-&gt;keys++ = *src-&gt;keys++;</span><br><span class="line">    <span class="keyword">if</span> (dst-&gt;values != <span class="literal">NULL</span>)</span><br><span class="line">        *dst-&gt;values++ = *src-&gt;values++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Py_LOCAL_INLINE(<span class="keyword">void</span>)</span><br><span class="line">sortslice_copy_decr(sortslice *dst, sortslice *src)</span><br><span class="line">&#123;</span><br><span class="line">    *dst-&gt;keys-- = *src-&gt;keys--;</span><br><span class="line">    <span class="keyword">if</span> (dst-&gt;values != <span class="literal">NULL</span>)</span><br><span class="line">        *dst-&gt;values-- = *src-&gt;values--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Py_LOCAL_INLINE(<span class="keyword">void</span>)</span><br><span class="line">sortslice_memcpy(sortslice *s1, Py_ssize_t i, sortslice *s2, Py_ssize_t j,</span><br><span class="line">                 Py_ssize_t n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;s1-&gt;keys[i], &amp;s2-&gt;keys[j], <span class="keyword">sizeof</span>(PyObject *) * n);</span><br><span class="line">    <span class="keyword">if</span> (s1-&gt;values != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;s1-&gt;values[i], &amp;s2-&gt;values[j], <span class="keyword">sizeof</span>(PyObject *) * n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Py_LOCAL_INLINE(<span class="keyword">void</span>)</span><br><span class="line">sortslice_memmove(sortslice *s1, Py_ssize_t i, sortslice *s2, Py_ssize_t j,</span><br><span class="line">                  Py_ssize_t n)</span><br><span class="line">&#123;</span><br><span class="line">    memmove(&amp;s1-&gt;keys[i], &amp;s2-&gt;keys[j], <span class="keyword">sizeof</span>(PyObject *) * n);</span><br><span class="line">    <span class="keyword">if</span> (s1-&gt;values != <span class="literal">NULL</span>)</span><br><span class="line">        memmove(&amp;s1-&gt;values[i], &amp;s2-&gt;values[j], <span class="keyword">sizeof</span>(PyObject *) * n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Py_LOCAL_INLINE(<span class="keyword">void</span>)</span><br><span class="line">sortslice_advance(sortslice *slice, Py_ssize_t n)</span><br><span class="line">&#123;</span><br><span class="line">    slice-&gt;keys += n;</span><br><span class="line">    <span class="keyword">if</span> (slice-&gt;values != <span class="literal">NULL</span>)</span><br><span class="line">        slice-&gt;values += n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>随后定义了一大串用来操作<code>sortslice</code>的内联函数，基本上类似于一个“类”了。这些函数简单来说就是优先处理<code>key</code>，然后如果有<code>value</code>再对<code>value</code>做一样的操作。不论调用排序时有没有<code>key</code>这个参数，待排序的元素都在<code>key</code>中，只不过如果有<code>key</code>这个参数<strong>原数组</strong>的元素被移动到了<code>value</code>里。<code>Py_LOCAL_INLINE</code>的定义依平台而定，目标是实现最快速的局域函数调用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Comparison function: ms-&gt;key_compare, which is set at run-time in</span></span><br><span class="line"><span class="comment"> * listsort_impl to optimize for various special cases.</span></span><br><span class="line"><span class="comment"> * Returns -1 on error, 1 if x &lt; y, 0 if x &gt;= y.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISLT(X, Y) (*(ms-&gt;key_compare))(X, Y, ms)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Compare X to Y via "&lt;".  Goto "fail" if the comparison raises an</span></span><br><span class="line"><span class="comment">   error.  Else "k" is set to true iff X&lt;Y, and an "if (k)" block is</span></span><br><span class="line"><span class="comment">   started.  It makes more sense in context &lt;wink&gt;.  X and Y are PyObject*s.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IFLT(X, Y) <span class="meta-keyword">if</span> ((k = ISLT(X, Y)) &lt; 0) goto fail;  \</span></span><br><span class="line">           <span class="keyword">if</span> (k)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The maximum number of entries in a MergeState's pending-runs stack.</span></span><br><span class="line"><span class="comment"> * This is enough to sort arrays of size up to about</span></span><br><span class="line"><span class="comment"> *     32 * phi ** MAX_MERGE_PENDING</span></span><br><span class="line"><span class="comment"> * where phi ~= 1.618.  85 is ridiculouslylarge enough, good for an array</span></span><br><span class="line"><span class="comment"> * with 2**64 elements.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_MERGE_PENDING 85</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* When we get into galloping mode, we stay there until both runs win less</span></span><br><span class="line"><span class="comment"> * often than MIN_GALLOP consecutive times.  See listsort.txt for more info.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_GALLOP 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Avoid malloc for small temp arrays. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MERGESTATE_TEMP_SIZE 256</span></span><br></pre></td></tr></table></figure></p>
<p>再然后定义了一些宏。比较大小的宏让人心痛：CPython里要比较元素大小的overhead还是相当大的。<code>MAX_MERGE_PENDING</code>和<code>MIN_GALLOP</code>的注释都做的非常清楚，把数值的选择交代明白了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* One MergeState exists on the stack per invocation of mergesort.  It's just</span></span><br><span class="line"><span class="comment"> * a convenient way to pass state around among the helper functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_slice</span> &#123;</span></span><br><span class="line">    sortslice base;</span><br><span class="line">    Py_ssize_t len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_MergeState</span> <span class="title">MergeState</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_MergeState</span> &#123;</span></span><br><span class="line">    <span class="comment">/* This controls when we get *into* galloping mode.  It's initialized</span></span><br><span class="line"><span class="comment">     * to MIN_GALLOP.  merge_lo and merge_hi tend to nudge it higher for</span></span><br><span class="line"><span class="comment">     * random data, and lower for highly structured data.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Py_ssize_t min_gallop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 'a' is temp storage to help with merges.  It contains room for</span></span><br><span class="line"><span class="comment">     * alloced entries.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    sortslice a;        <span class="comment">/* may point to temparray below */</span></span><br><span class="line">    Py_ssize_t alloced;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* A stack of n pending runs yet to be merged.  Run #i starts at</span></span><br><span class="line"><span class="comment">     * address base[i] and extends for len[i] elements.  It's always</span></span><br><span class="line"><span class="comment">     * true (so long as the indices are in bounds) that</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     pending[i].base + pending[i].len == pending[i+1].base</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * so we could cut the storage for this, but it's a minor amount,</span></span><br><span class="line"><span class="comment">     * and keeping all the info explicit simplifies the code.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s_slice</span> <span class="title">pending</span>[<span class="title">MAX_MERGE_PENDING</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 'a' points to this when possible, rather than muck with malloc. */</span></span><br><span class="line">    PyObject *temparray[MERGESTATE_TEMP_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is the function we will use to compare two keys,</span></span><br><span class="line"><span class="comment">     * even when none of our special cases apply and we have to use</span></span><br><span class="line"><span class="comment">     * safe_object_compare. */</span></span><br><span class="line">    <span class="keyword">int</span> (*key_compare)(PyObject *, PyObject *, MergeState *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This function is used by unsafe_object_compare to optimize comparisons</span></span><br><span class="line"><span class="comment">     * when we know our list is type-homogeneous but we can't assume anything else.</span></span><br><span class="line"><span class="comment">     * In the pre-sort check it is set equal to key-&gt;ob_type-&gt;tp_richcompare */</span></span><br><span class="line">    PyObject *(*key_richcompare)(PyObject *, PyObject *, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This function is used by unsafe_tuple_compare to compare the first elements</span></span><br><span class="line"><span class="comment">     * of tuples. It may be set to safe_object_compare, but the idea is that hopefully</span></span><br><span class="line"><span class="comment">     * we can assume more, and use one of the special-case compares. */</span></span><br><span class="line">    <span class="keyword">int</span> (*tuple_elem_compare)(PyObject *, PyObject *, MergeState *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面首先利用<code>s_slice</code>对<code>sortslice</code>进行了进一步包装，添加了长度字段，形成了一个完整的run的结构。然后定义了一个<code>MergeState</code>，用于包装进行Timsort时的众多metadata，在传参时比较方便。里面有一些对Timsort具有明显关键作用的参数如<code>min_gallop</code>、保存run的栈<code>pending</code>、进行merge时的临时空间<code>temparray</code>以及与之相关的指针等，也有一些为Python的泛型特点准备的函数指针。</p>
<h2 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h2><p>很多基于比较的排序或多或少都依赖强大的插入排序对小的数据片段进行处理，Timsort也不例外，而且使用得相当巧妙。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* binarysort is the best method for sorting small arrays: it does</span></span><br><span class="line"><span class="comment">   few compares, but can do data movement quadratic in the number of</span></span><br><span class="line"><span class="comment">   elements.</span></span><br><span class="line"><span class="comment">   [lo, hi) is a contiguous slice of a list, and is sorted via</span></span><br><span class="line"><span class="comment">   binary insertion.  This sort is stable.</span></span><br><span class="line"><span class="comment">   On entry, must have lo &lt;= start &lt;= hi, and that [lo, start) is already</span></span><br><span class="line"><span class="comment">   sorted (pass start == lo if you don't know!).</span></span><br><span class="line"><span class="comment">   If islt() complains return -1, else 0.</span></span><br><span class="line"><span class="comment">   Even in case of error, the output slice will be some permutation of</span></span><br><span class="line"><span class="comment">   the input (nothing is lost or duplicated).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">binarysort(MergeState *ms, sortslice lo, PyObject **hi, PyObject **start)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t k;</span><br><span class="line">    PyObject **l, **p, **r;</span><br><span class="line">    PyObject *pivot;</span><br><span class="line"></span><br><span class="line">    assert(lo.keys &lt;= start &amp;&amp; start &lt;= hi);</span><br><span class="line">    <span class="comment">/* assert [lo, start) is sorted */</span></span><br><span class="line">    <span class="keyword">if</span> (lo.keys == start)</span><br><span class="line">        ++start;</span><br><span class="line">    <span class="keyword">for</span> (; start &lt; hi; ++start) &#123;</span><br><span class="line">        <span class="comment">/* set l to where *start belongs */</span></span><br><span class="line">        l = lo.keys;</span><br><span class="line">        r = start;</span><br><span class="line">        pivot = *r;</span><br><span class="line">        <span class="comment">/* Invariants:</span></span><br><span class="line"><span class="comment">         * pivot &gt;= all in [lo, l).</span></span><br><span class="line"><span class="comment">         * pivot  &lt; all in [r, start).</span></span><br><span class="line"><span class="comment">         * The second is vacuously true at the start.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        assert(l &lt; r);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            p = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            IFLT(pivot, *p)</span><br><span class="line">                r = p;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = p+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (l &lt; r);</span><br><span class="line">        assert(l == r);</span><br><span class="line">        <span class="comment">/* The invariants still hold, so pivot &gt;= all in [lo, l) and</span></span><br><span class="line"><span class="comment">           pivot &lt; all in [l, start), so pivot belongs at l.  Note</span></span><br><span class="line"><span class="comment">           that if there are elements equal to pivot, l points to the</span></span><br><span class="line"><span class="comment">           first slot after them -- that's why this sort is stable.</span></span><br><span class="line"><span class="comment">           Slide over to make room.</span></span><br><span class="line"><span class="comment">           Caution: using memmove is much slower under MSVC 5;</span></span><br><span class="line"><span class="comment">           we're not usually moving many slots. */</span></span><br><span class="line">        <span class="keyword">for</span> (p = start; p &gt; l; --p)</span><br><span class="line">            *p = *(p<span class="number">-1</span>);</span><br><span class="line">        *l = pivot;</span><br><span class="line">        <span class="keyword">if</span> (lo.values != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_ssize_t offset = lo.values - lo.keys;</span><br><span class="line">            p = start + offset;</span><br><span class="line">            pivot = *p;</span><br><span class="line">            l += offset;</span><br><span class="line">            <span class="keyword">for</span> (p = start + offset; p &gt; l; --p)</span><br><span class="line">                *p = *(p<span class="number">-1</span>);</span><br><span class="line">            *l = pivot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> fail:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Timsort中的二分插入排序和一般的二分插入排序不一样的地方在于额外多了一些参数，特别是<code>start</code>。我们来看一下这个排序函数的参数都是什么含义。</p>
<ol>
<li><code>ms</code>包含了非常多的信息，粗看起来好像在当前函数中没有用到，其实为大小比较提供了进行比较的函数。</li>
<li><code>lo</code>里面是两个指针，指向当前待排序的<code>key</code>和<code>value</code>的地址。</li>
<li><code>hi</code>是单个指针，指向待排序的<code>key</code>的结束地址。</li>
<li><code>start</code>指向开始排序的元素的地址。这是Timsort中二分插入排序和其它二分插入排序的最大区别。一般的排序是不需要这个指针的，直接从头开始排就行了。Timsort需要这个指针的原因是Timsort需要把长度不够一个run的单调序列强行拉成一个run长。这样形成的run前半部分是单调的有序的，后半部分是不单调的无序的，那么要把这个run变成有序的就可以把不单调的部分与前面单调的部分一起放到这个二分插入排序里来进行排序，这时我们知道<code>start</code>之前已经是单调的了，因此从<code>start</code>开始排序即可。通过这个二分插入排序函数我们不难想象在数据比较随机的时候Timsort可以很自然地退化为mergesort。</li>
</ol>
<p>除此之外，在这个二分插入排序最后，我们看到了在排序完毕后将<code>value</code>的值也进行位移、插入的过程。为什么不在对<code>key</code>排序的时候顺便就把在一个结构里的<code>value</code>的一起做了呢？因为数据局部性啊。</p>
<h2 id="山雨欲来风满楼"><a href="#山雨欲来风满楼" class="headerlink" title="山雨欲来风满楼"></a>山雨欲来风满楼</h2><p>下面就要进入Timsort最精华最出彩的部分了。首先登场的是<code>count_run</code>函数。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Return <span class="keyword">the</span> <span class="built_in">length</span> <span class="keyword">of</span> <span class="keyword">the</span> <span class="built_in">run</span> <span class="keyword">beginning</span> <span class="keyword">at</span> lo, <span class="keyword">in</span> <span class="keyword">the</span> slice [lo, hi).  lo &lt; hi</span><br><span class="line"><span class="keyword">is</span> required <span class="keyword">on</span> entry.  <span class="string">"A run"</span> <span class="keyword">is</span> <span class="keyword">the</span> longest ascending sequence, <span class="keyword">with</span></span><br><span class="line"></span><br><span class="line">    lo[<span class="number">0</span>] &lt;= lo[<span class="number">1</span>] &lt;= lo[<span class="number">2</span>] &lt;= ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span> <span class="keyword">the</span> longest descending sequence, <span class="keyword">with</span></span><br><span class="line"></span><br><span class="line">    lo[<span class="number">0</span>] &gt; lo[<span class="number">1</span>] &gt; lo[<span class="number">2</span>] &gt; ...</span><br><span class="line"></span><br><span class="line">Boolean *descending <span class="keyword">is</span> <span class="keyword">set</span> <span class="keyword">to</span> <span class="number">0</span> <span class="keyword">in</span> <span class="keyword">the</span> former case, <span class="keyword">or</span> <span class="keyword">to</span> <span class="number">1</span> <span class="keyword">in</span> <span class="keyword">the</span> latter.</span><br><span class="line">For <span class="keyword">its</span> intended use <span class="keyword">in</span> a stable mergesort, <span class="keyword">the</span> strictness <span class="keyword">of</span> <span class="keyword">the</span> defn <span class="keyword">of</span></span><br><span class="line"><span class="string">"descending"</span> <span class="keyword">is</span> needed so <span class="keyword">that</span> <span class="keyword">the</span> caller can safely <span class="built_in">reverse</span> a descending</span><br><span class="line">sequence <span class="keyword">without</span> violating stability (strict &gt; ensures there are no <span class="keyword">equal</span></span><br><span class="line">elements <span class="keyword">to</span> <span class="keyword">get</span> <span class="keyword">out of</span> order).</span><br><span class="line"></span><br><span class="line">Returns <span class="number">-1</span> <span class="keyword">in</span> case <span class="keyword">of</span> <span class="keyword">error</span>.</span><br><span class="line">*/</span><br><span class="line">static Py_ssize_t</span><br><span class="line">count_run(MergeState *ms, PyObject **lo, PyObject **hi, int *descending)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t k;</span><br><span class="line">    Py_ssize_t n;</span><br><span class="line"></span><br><span class="line">    assert(lo &lt; hi);</span><br><span class="line">    *descending = <span class="number">0</span>;</span><br><span class="line">    ++lo;</span><br><span class="line">    <span class="keyword">if</span> (lo == hi)</span><br><span class="line"><span class="built_in">        return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    n = <span class="number">2</span>;</span><br><span class="line">    IFLT<span class="comment">(*lo, *(lo-1)) &#123;</span></span><br><span class="line"><span class="comment">        *descending = 1;</span></span><br><span class="line"><span class="comment">        for (lo = lo+1; lo &lt; hi; ++lo, ++n) &#123;</span></span><br><span class="line"><span class="comment">            IFLT<span class="comment">(*lo, *(lo-1))</span></span></span><br><span class="line"><span class="comment"><span class="comment">                ;</span></span></span><br><span class="line"><span class="comment"><span class="comment">            else</span></span></span><br><span class="line"><span class="comment"><span class="comment">                break;</span></span></span><br><span class="line"><span class="comment"><span class="comment">        &#125;</span></span></span><br><span class="line"><span class="comment"><span class="comment">    &#125;</span></span></span><br><span class="line"><span class="comment"><span class="comment">    else &#123;</span></span></span><br><span class="line"><span class="comment"><span class="comment">        for (lo = lo+1; lo &lt; hi; ++lo, ++n) &#123;</span></span></span><br><span class="line"><span class="comment"><span class="comment">            IFLT<span class="comment">(*lo, *(lo-1))</span></span></span></span><br><span class="line"><span class="comment"><span class="comment"><span class="comment">                break;</span></span></span></span><br><span class="line"><span class="comment"><span class="comment"><span class="comment">        &#125;</span></span></span></span><br><span class="line"><span class="comment"><span class="comment"><span class="comment">    &#125;</span></span></span></span><br><span class="line"><span class="comment"><span class="comment"><span class="comment"></span></span></span></span><br><span class="line"><span class="comment"><span class="comment"><span class="comment">    return n;</span></span></span></span><br><span class="line"><span class="comment"><span class="comment"><span class="comment">fail:</span></span></span></span><br><span class="line"><span class="comment"><span class="comment"><span class="comment">    return -1;</span></span></span></span><br><span class="line"><span class="comment"><span class="comment"><span class="comment">&#125;</span></span></span></span><br></pre></td></tr></table></figure></p>
<p>这个函数从<code>lo</code>规定的地方开始，到<code>hi</code>规定的地方结束，寻找一个单调的序列作为run的前体（长度不够再来凑）。注意这里如果是单调增不要求严格单调，但是单调减要求是严格的。这是因为Timsort会反转单调减的序列把它变成单调增，我们不希望单调减序列中有相同元素使反转操作导致排序不稳定，严格要求单调减时翻转需要处理的元素数目较少也是一个bonus。因此这里的单调/严格单调要求不是随意选择的。</p>
<h2 id="Gallop"><a href="#Gallop" class="headerlink" title="Gallop!"></a>Gallop!</h2><p>接下来是威名远扬的gallop函数，本质是对待查找元素常常位于有序数组某一端这种情况进行优化的二分查找。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Locate the proper position of key in a sorted vector; if the vector contains</span></span><br><span class="line"><span class="comment">an element equal to key, return the position immediately to the left of</span></span><br><span class="line"><span class="comment">the leftmost equal element.  [gallop_right() does the same except returns</span></span><br><span class="line"><span class="comment">the position to the right of the rightmost equal element (if any).]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">"a" is a sorted vector with n elements, starting at a[0].  n must be &gt; 0.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">"hint" is an index at which to begin the search, 0 &lt;= hint &lt; n.  The closer</span></span><br><span class="line"><span class="comment">hint is to the final result, the faster this runs.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The return value is the int k in 0..n such that</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    a[k-1] &lt; key &lt;= a[k]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">pretending that *(a-1) is minus infinity and a[n] is plus infinity.  IOW,</span></span><br><span class="line"><span class="comment">key belongs at index k; or, IOW, the first k elements of a should precede</span></span><br><span class="line"><span class="comment">key, and the last n-k should follow key.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Returns -1 on error.  See listsort.txt for info on the method.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> Py_ssize_t</span><br><span class="line">gallop_left(MergeState *ms, PyObject *key, PyObject **a, Py_ssize_t n, Py_ssize_t hint)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t ofs;</span><br><span class="line">    Py_ssize_t lastofs;</span><br><span class="line">    Py_ssize_t k;</span><br><span class="line"></span><br><span class="line">    assert(key &amp;&amp; a &amp;&amp; n &gt; <span class="number">0</span> &amp;&amp; hint &gt;= <span class="number">0</span> &amp;&amp; hint &lt; n);</span><br><span class="line"></span><br><span class="line">    a += hint;</span><br><span class="line">    lastofs = <span class="number">0</span>;</span><br><span class="line">    ofs = <span class="number">1</span>;</span><br><span class="line">    IFLT(*a, key) &#123;</span><br><span class="line">        <span class="comment">/* a[hint] &lt; key -- gallop right, until</span></span><br><span class="line"><span class="comment">         * a[hint + lastofs] &lt; key &lt;= a[hint + ofs]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">const</span> Py_ssize_t maxofs = n - hint;             <span class="comment">/* &amp;a[n-1] is highest */</span></span><br><span class="line">        <span class="keyword">while</span> (ofs &lt; maxofs) &#123;</span><br><span class="line">            IFLT(a[ofs], key) &#123;</span><br><span class="line">                lastofs = ofs;</span><br><span class="line">                ofs = (ofs &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (ofs &lt;= <span class="number">0</span>)                   <span class="comment">/* int overflow */</span></span><br><span class="line">                    ofs = maxofs;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                <span class="comment">/* key &lt;= a[hint + ofs] */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ofs &gt; maxofs)</span><br><span class="line">            ofs = maxofs;</span><br><span class="line">        <span class="comment">/* Translate back to offsets relative to &amp;a[0]. */</span></span><br><span class="line">        lastofs += hint;</span><br><span class="line">        ofs += hint;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* key &lt;= a[hint] -- gallop left, until</span></span><br><span class="line"><span class="comment">         * a[hint - ofs] &lt; key &lt;= a[hint - lastofs]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">const</span> Py_ssize_t maxofs = hint + <span class="number">1</span>;             <span class="comment">/* &amp;a[0] is lowest */</span></span><br><span class="line">        <span class="keyword">while</span> (ofs &lt; maxofs) &#123;</span><br><span class="line">            IFLT(*(a-ofs), key)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/* key &lt;= a[hint - ofs] */</span></span><br><span class="line">            lastofs = ofs;</span><br><span class="line">            ofs = (ofs &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (ofs &lt;= <span class="number">0</span>)               <span class="comment">/* int overflow */</span></span><br><span class="line">                ofs = maxofs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ofs &gt; maxofs)</span><br><span class="line">            ofs = maxofs;</span><br><span class="line">        <span class="comment">/* Translate back to positive offsets relative to &amp;a[0]. */</span></span><br><span class="line">        k = lastofs;</span><br><span class="line">        lastofs = hint - ofs;</span><br><span class="line">        ofs = hint - k;</span><br><span class="line">    &#125;</span><br><span class="line">    a -= hint;</span><br><span class="line"></span><br><span class="line">    assert(<span class="number">-1</span> &lt;= lastofs &amp;&amp; lastofs &lt; ofs &amp;&amp; ofs &lt;= n);</span><br><span class="line">    <span class="comment">/* Now a[lastofs] &lt; key &lt;= a[ofs], so key belongs somewhere to the</span></span><br><span class="line"><span class="comment">     * right of lastofs but no farther right than ofs.  Do a binary</span></span><br><span class="line"><span class="comment">     * search, with invariant a[lastofs-1] &lt; key &lt;= a[ofs].</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ++lastofs;</span><br><span class="line">    <span class="keyword">while</span> (lastofs &lt; ofs) &#123;</span><br><span class="line">        Py_ssize_t m = lastofs + ((ofs - lastofs) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        IFLT(a[m], key)</span><br><span class="line">            lastofs = m+<span class="number">1</span>;              <span class="comment">/* a[m] &lt; key */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ofs = m;                    <span class="comment">/* key &lt;= a[m] */</span></span><br><span class="line">    &#125;</span><br><span class="line">    assert(lastofs == ofs);             <span class="comment">/* so a[ofs-1] &lt; key &lt;= a[ofs] */</span></span><br><span class="line">    <span class="keyword">return</span> ofs;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>几个参数都比较显然，<code>hint</code>看起来很fancy但在实际当中并没有得到有效应用，其值往往都是端点位置。如果<code>hint</code>的取值多一些，gallop函数就可以看做是针对待查找元素常常位于有序数组某一特定位置（<code>hint</code>）附近的情况进行优化的二分查找。与一般的查找函数不同，这一函数的返回值是带查找元素相对于<code>hint</code>的偏移量，这是为了方便算法中对偏移量的使用而设计的接口。<br>Gallop函数主要分为两个大块，第一块是一段if-else，通过gallop找到<code>key</code>大概在的区间，然后第二块通过二分查找确定<code>key</code>的位置。if-else段两个逻辑也很类似，只不过一个是往右gallop一个是往左gallop。两段最大的区别在于从相对于<code>hint</code>的offset换算成相对于数组起始地址的offset时逻辑不太一样，因为当向左gallop时需要调换<code>ofs</code>和<code>lastofs</code>的位置。这段代码首先要夸作者注释做的好，不多但是把最最关键的都点得清清楚楚，读起来好似按摩神经。然后还要夸对于int overflow的细节的处理，这让我一个基本上只写Python的肃然起敬。这里贴上来的代码是<code>gallop_left</code>，那么同理还有<code>gallop_right</code>，不同之处在于有多个与<code>key</code>相同的元素时的处理。<code>gallop_left</code>在有多个相同元素时会返回数组最左侧的元素，相反<code>gallop_right</code>会返回数组最右侧的元素。这是为了实现算法稳定性而做出的区别对待，与“向左查找”或者“向右查找”没有关系。<br>以上对gallop函数的分析看起来好像很简单，其实gallop函数中的学问还是非常多的，具体的可以看Tim本人写的小文章。这里请读者思考一个问题：为什么在将offset进行翻倍操作时要多加一个1呢？也就是说，为什么会有:<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ofs</span> = (ofs &lt;&lt; 1) + 1;</span><br></pre></td></tr></table></figure></p>
<p>而不是更简单的：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ofs &lt;&lt;= <span class="number">1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>经本人测试，这个小区别几乎决定了gallop函数是一个有效的改进还是画蛇添足。如果在offset翻倍时采用简单的位移操作，不进行gallop的Timsort会比进行gallop的Timsort整体来说表现更好。这个小问题的答案在Tim的小文章中做了详细的介绍。<br>下面就要做<code>merge</code>了。</p>
<h2 id="Merge的基础设施"><a href="#Merge的基础设施" class="headerlink" title="Merge的基础设施"></a>Merge的基础设施</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Conceptually a MergeState's constructor. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">merge_init(MergeState *ms, Py_ssize_t list_size, <span class="keyword">int</span> has_keyfunc)</span><br><span class="line">&#123;</span><br><span class="line">    assert(ms != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (has_keyfunc) &#123;</span><br><span class="line">        <span class="comment">/* The temporary space for merging will need at most half the list</span></span><br><span class="line"><span class="comment">         * size rounded up.  Use the minimum possible space so we can use the</span></span><br><span class="line"><span class="comment">         * rest of temparray for other things.  In particular, if there is</span></span><br><span class="line"><span class="comment">         * enough extra space, listsort() will use it to store the keys.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ms-&gt;alloced = (list_size + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ms-&gt;alloced describes how many keys will be stored at</span></span><br><span class="line"><span class="comment">           ms-&gt;temparray, but we also need to store the values.  Hence,</span></span><br><span class="line"><span class="comment">           ms-&gt;alloced is capped at half of MERGESTATE_TEMP_SIZE. */</span></span><br><span class="line">        <span class="keyword">if</span> (MERGESTATE_TEMP_SIZE / <span class="number">2</span> &lt; ms-&gt;alloced)</span><br><span class="line">            ms-&gt;alloced = MERGESTATE_TEMP_SIZE / <span class="number">2</span>;</span><br><span class="line">        ms-&gt;a.values = &amp;ms-&gt;temparray[ms-&gt;alloced];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ms-&gt;alloced = MERGESTATE_TEMP_SIZE;</span><br><span class="line">        ms-&gt;a.values = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ms-&gt;a.keys = ms-&gt;temparray;</span><br><span class="line">    ms-&gt;n = <span class="number">0</span>;</span><br><span class="line">    ms-&gt;min_gallop = MIN_GALLOP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free all the temp memory owned by the MergeState.  This must be called</span></span><br><span class="line"><span class="comment"> * when you're done with a MergeState, and may be called before then if</span></span><br><span class="line"><span class="comment"> * you want to free the temp memory early.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">merge_freemem(MergeState *ms)</span><br><span class="line">&#123;</span><br><span class="line">    assert(ms != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ms-&gt;a.keys != ms-&gt;temparray)</span><br><span class="line">        PyMem_Free(ms-&gt;a.keys);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ensure enough temp memory for 'need' array slots is available.</span></span><br><span class="line"><span class="comment"> * Returns 0 on success and -1 if the memory can't be gotten.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">merge_getmem(MergeState *ms, Py_ssize_t need)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> multiplier;</span><br><span class="line"></span><br><span class="line">    assert(ms != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (need &lt;= ms-&gt;alloced)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    multiplier = ms-&gt;a.values != <span class="literal">NULL</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't realloc!  That can cost cycles to copy the old data, but</span></span><br><span class="line"><span class="comment">     * we don't care what's in the block.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    merge_freemem(ms);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">size_t</span>)need &gt; PY_SSIZE_T_MAX / <span class="keyword">sizeof</span>(PyObject *) / multiplier) &#123;</span><br><span class="line">        PyErr_NoMemory();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ms-&gt;a.keys = (PyObject **)PyMem_Malloc(multiplier * need</span><br><span class="line">                                          * <span class="keyword">sizeof</span>(PyObject *));</span><br><span class="line">    <span class="keyword">if</span> (ms-&gt;a.keys != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ms-&gt;alloced = need;</span><br><span class="line">        <span class="keyword">if</span> (ms-&gt;a.values != <span class="literal">NULL</span>)</span><br><span class="line">            ms-&gt;a.values = &amp;ms-&gt;a.keys[need];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PyErr_NoMemory();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MERGE_GETMEM(MS, NEED) ((NEED) <span class="meta-string">&lt;= (MS)-&gt;alloced ? 0 :   \</span></span></span><br><span class="line">                                merge_getmem(MS, NEED))</span><br></pre></td></tr></table></figure>
<p>首先是一个类似<code>MergeState</code>构造函数的函数，不难发现这个函数并不是严格的构造函数，有许多变量都没处理，调用的时候其实也只被调用了一次，所以个人感觉这个函数意义并不是很大。之后是对<code>MergeState</code>维护的临时空间内存进行管理的函数。在<code>merge_getmem</code>里有一个貌似很奇怪的<code>multiplier</code>，这是由于当同时存在<code>key</code>和<code>value</code>时，所需要的空间两倍于只有<code>key</code>时的空间。最后定义的<code>MERGE_GETMEM</code>看起来和<code>merge_getmem</code>中实现的功能完全重叠，不知为何，等CPython开启issue以后一定要问一下。</p>
<h2 id="merge-阴阳太极"><a href="#merge-阴阳太极" class="headerlink" title="merge-阴阳太极"></a>merge-阴阳太极</h2><p>为什么叫“阴阳太极”呢？因为有关merge的代码包含了一些的对偶的部分，而这些对偶的部分又相互依赖相互补充。比如下面这个针对<code>na &lt;= nb</code>时的<code>merge_lo</code>函数，需要在gallop mode和正常mode里面跳来跳去。这样的逻辑使代码相对复杂，不过从这里我们看到了C中<code>goto</code>的巧妙应用。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Merge the na elements starting at ssa with the nb elements starting at</span></span><br><span class="line"><span class="comment"> * ssb.keys = ssa.keys + na in a stable way, in-place.  na and nb must be &gt; 0.</span></span><br><span class="line"><span class="comment"> * Must also have that ssa.keys[na-1] belongs at the end of the merge, and</span></span><br><span class="line"><span class="comment"> * should have na &lt;= nb.  See listsort.txt for more info.  Return 0 if</span></span><br><span class="line"><span class="comment"> * successful, -1 if error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">static Py_ssize_t</span><br><span class="line">merge_lo(MergeState *ms, sortslice ssa, Py_ssize_t na,</span><br><span class="line">         sortslice ssb, Py_ssize_t nb)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t k<span class="comment">;</span></span><br><span class="line">    sortslice dest<span class="comment">;</span></span><br><span class="line">    int result = -<span class="number">1</span><span class="comment">;            /* guilty until proved innocent */</span></span><br><span class="line">    Py_ssize_t min_gallop<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    assert(ms &amp;&amp; ssa.keys &amp;&amp; ssb.keys &amp;&amp; na &gt; <span class="number">0</span> &amp;&amp; nb &gt; <span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">    assert(ssa.keys + na == ssb.keys)<span class="comment">;</span></span><br><span class="line">    if (MERGE_GETMEM(ms, na) &lt; <span class="number">0</span>)</span><br><span class="line">        return -<span class="number">1</span><span class="comment">;</span></span><br><span class="line">    sortslice_memcpy(&amp;ms-&gt;a, <span class="number">0</span>, &amp;ssa, <span class="number">0</span>, na)<span class="comment">;</span></span><br><span class="line">    dest = ssa<span class="comment">;</span></span><br><span class="line">    ssa = ms-&gt;a<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    sortslice_copy_incr(&amp;dest, &amp;ssb)<span class="comment">;</span></span><br><span class="line">    --nb<span class="comment">;</span></span><br><span class="line">    if (nb == <span class="number">0</span>)</span><br><span class="line">        goto Succeed<span class="comment">;</span></span><br><span class="line">    if (na == <span class="number">1</span>)</span><br><span class="line">        goto CopyB<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    min_gallop = ms-&gt;min_gallop<span class="comment">;</span></span><br><span class="line">    for (<span class="comment">;;) &#123;</span></span><br><span class="line">        Py_ssize_t acount = <span class="number">0</span><span class="comment">;          /* # of times A won in a row */</span></span><br><span class="line">        Py_ssize_t <span class="keyword">bcount </span>= <span class="number">0</span><span class="comment">;          /* # of times B won in a row */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Do the straightforward thing until (if ever) one run</span></span><br><span class="line"><span class="comment">         * appears to win consistently.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        for (<span class="comment">;;) &#123;</span></span><br><span class="line">            assert(na &gt; <span class="number">1</span> &amp;&amp; nb &gt; <span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">            k = ISLT(ssb.keys[<span class="number">0</span>], ssa.keys[<span class="number">0</span>])<span class="comment">;</span></span><br><span class="line">            if (k) &#123;</span><br><span class="line">                if (k &lt; <span class="number">0</span>)</span><br><span class="line">                    goto Fail<span class="comment">;</span></span><br><span class="line">                sortslice_copy_incr(&amp;dest, &amp;ssb)<span class="comment">;</span></span><br><span class="line">                ++<span class="keyword">bcount;</span></span><br><span class="line"><span class="keyword"> </span>               acount = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">                --nb<span class="comment">;</span></span><br><span class="line">                if (nb == <span class="number">0</span>)</span><br><span class="line">                    goto Succeed<span class="comment">;</span></span><br><span class="line">                if (<span class="keyword">bcount </span>&gt;= min_gallop)</span><br><span class="line">                    <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"> </span>           &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                sortslice_copy_incr(&amp;dest, &amp;ssa)<span class="comment">;</span></span><br><span class="line">                ++acount<span class="comment">;</span></span><br><span class="line">                <span class="keyword">bcount </span>= <span class="number">0</span><span class="comment">;</span></span><br><span class="line">                --na<span class="comment">;</span></span><br><span class="line">                if (na == <span class="number">1</span>)</span><br><span class="line">                    goto CopyB<span class="comment">;</span></span><br><span class="line">                if (acount &gt;= min_gallop)</span><br><span class="line">                    <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"> </span>           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* One run is winning so consistently that galloping may</span></span><br><span class="line"><span class="comment">         * be a huge win.  So try that, and continue galloping until</span></span><br><span class="line"><span class="comment">         * (if ever) neither run appears to be winning consistently</span></span><br><span class="line"><span class="comment">         * anymore.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ++min_gallop<span class="comment">;</span></span><br><span class="line">        do &#123;</span><br><span class="line">            assert(na &gt; <span class="number">1</span> &amp;&amp; nb &gt; <span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">            min_gallop -= min_gallop &gt; <span class="number">1</span><span class="comment">;</span></span><br><span class="line">            ms-&gt;min_gallop = min_gallop<span class="comment">;</span></span><br><span class="line">            k = gallop_right(ms, ssb.keys[<span class="number">0</span>], ssa.keys, na, <span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">            acount = k<span class="comment">;</span></span><br><span class="line">            if (k) &#123;</span><br><span class="line">                if (k &lt; <span class="number">0</span>)</span><br><span class="line">                    goto Fail<span class="comment">;</span></span><br><span class="line">                sortslice_memcpy(&amp;dest, <span class="number">0</span>, &amp;ssa, <span class="number">0</span>, k)<span class="comment">;</span></span><br><span class="line">                sortslice_advance(&amp;dest, k)<span class="comment">;</span></span><br><span class="line">                sortslice_advance(&amp;ssa, k)<span class="comment">;</span></span><br><span class="line">                na -= k<span class="comment">;</span></span><br><span class="line">                if (na == <span class="number">1</span>)</span><br><span class="line">                    goto CopyB<span class="comment">;</span></span><br><span class="line">                <span class="comment">/* na==0 is impossible now if the comparison</span></span><br><span class="line"><span class="comment">                 * function is consistent, but we can't assume</span></span><br><span class="line"><span class="comment">                 * that it is.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                if (na == <span class="number">0</span>)</span><br><span class="line">                    goto Succeed<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">            sortslice_copy_incr(&amp;dest, &amp;ssb)<span class="comment">;</span></span><br><span class="line">            --nb<span class="comment">;</span></span><br><span class="line">            if (nb == <span class="number">0</span>)</span><br><span class="line">                goto Succeed<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">            k = gallop_left(ms, ssa.keys[<span class="number">0</span>], ssb.keys, nb, <span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">            <span class="keyword">bcount </span>= k<span class="comment">;</span></span><br><span class="line">            if (k) &#123;</span><br><span class="line">                if (k &lt; <span class="number">0</span>)</span><br><span class="line">                    goto Fail<span class="comment">;</span></span><br><span class="line">                sortslice_memmove(&amp;dest, <span class="number">0</span>, &amp;ssb, <span class="number">0</span>, k)<span class="comment">;</span></span><br><span class="line">                sortslice_advance(&amp;dest, k)<span class="comment">;</span></span><br><span class="line">                sortslice_advance(&amp;ssb, k)<span class="comment">;</span></span><br><span class="line">                nb -= k<span class="comment">;</span></span><br><span class="line">                if (nb == <span class="number">0</span>)</span><br><span class="line">                    goto Succeed<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">            sortslice_copy_incr(&amp;dest, &amp;ssa)<span class="comment">;</span></span><br><span class="line">            --na<span class="comment">;</span></span><br><span class="line">            if (na == <span class="number">1</span>)</span><br><span class="line">                goto CopyB<span class="comment">;</span></span><br><span class="line">        &#125; while (acount &gt;= MIN_GALLOP <span class="title">||</span> <span class="keyword">bcount </span>&gt;= MIN_GALLOP)<span class="comment">;</span></span><br><span class="line">        ++min_gallop<span class="comment">;           /* penalize it for leaving galloping mode */</span></span><br><span class="line">        ms-&gt;min_gallop = min_gallop<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="symbol">Succeed:</span></span><br><span class="line">    result = <span class="number">0</span><span class="comment">;</span></span><br><span class="line"><span class="symbol">Fail:</span></span><br><span class="line">    if (na)</span><br><span class="line">        sortslice_memcpy(&amp;dest, <span class="number">0</span>, &amp;ssa, <span class="number">0</span>, na)<span class="comment">;</span></span><br><span class="line">    return result<span class="comment">;</span></span><br><span class="line"><span class="symbol">CopyB:</span></span><br><span class="line">    assert(na == <span class="number">1</span> &amp;&amp; nb &gt; <span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">    <span class="comment">/* The last element of ssa belongs at the end of the merge. */</span></span><br><span class="line">    sortslice_memmove(&amp;dest, <span class="number">0</span>, &amp;ssb, <span class="number">0</span>, nb)<span class="comment">;</span></span><br><span class="line">    sortslice_copy(&amp;dest, nb, &amp;ssa, <span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">    return <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数一开始的预处理主要是把较小的run拷贝到临时空间里去，最后的后处理也是想尽量利用<code>memmove</code>或者<code>memcpy</code>快速处理merge的尾巴。主要部分包含两个嵌套的循环，外层循环没有跳出条件，只能靠<code>goto</code>强行改变指令地址。如果使用其它语言想把这个功能写好恐怕不太容易，少不了一些奇奇怪怪的flag。内层循环有两个，第一个进行正常的merge，同时悄悄在小本本上记一些东西，最后要么成功要么切换模式；第二个进行gallop。gallop中好像进行了两次gallop，实际相当于是一个if-else，分别对应于不同数组上的gallop。在两次gallop中，除了对由gallop得到的大数组进行<code>memmove</code>或者<code>memcpy</code>以外，还会从没有gallop的数组中拷贝一个元素，因为这个元素正是在gallop中作为<code>key</code>比较的元素，在归并时根据定义恰好应该位于gallop得到的大数组之后。从中可以看出CPython这种一切以减少元素比较为中心的优化方式到了多么丧心病狂的地步。<br>依靠外层循环，算法得以在两种模式间不断切换。两个模式中间有个<code>++min_gallop</code>让人困惑——从正常模式切换到gallop难道不应该减小<code>min_gallop</code>吗？其实这里要加的原因是后面一进入gallop循环就要大力减。<br>除了<code>merge_lo</code>自然也有<code>merge_hi</code>，这一对merge是一般的归并排序没有的，因为一般的归并排序两段子数组长度类似，通常的也是符合直觉的做法是拷贝走第一个数组，这样可以从左往右扫归并。而在Timsort中可能存在第一个数组的长度比第二个数组要长的情况。为了节省空间、时间，要拷贝走第二个数组。这时再在第一个数组上进行归并可能就会覆盖第一个数组上的数据，只能在第二个数组上倒着来归并。这就导致<code>merge_lo</code>和<code>merge_hi</code>的实现有本质不同。但它们两个的基本精神还是一致的，因此这里不再赘述<code>merge_hi</code>了，直接来看<code>merge_lo</code>和<code>merge_hi</code>的调用者<code>merge_at</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Merge the two runs at stack indices i and i+1.</span></span><br><span class="line"><span class="comment"> * Returns 0 on success, -1 on error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> Py_ssize_t</span><br><span class="line">merge_at(MergeState *ms, Py_ssize_t i)</span><br><span class="line">&#123;</span><br><span class="line">    sortslice ssa, ssb;</span><br><span class="line">    Py_ssize_t na, nb;</span><br><span class="line">    Py_ssize_t k;</span><br><span class="line"></span><br><span class="line">    assert(ms != <span class="literal">NULL</span>);</span><br><span class="line">    assert(ms-&gt;n &gt;= <span class="number">2</span>);</span><br><span class="line">    assert(i &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(i == ms-&gt;n - <span class="number">2</span> || i == ms-&gt;n - <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    ssa = ms-&gt;pending[i].base;</span><br><span class="line">    na = ms-&gt;pending[i].len;</span><br><span class="line">    ssb = ms-&gt;pending[i+<span class="number">1</span>].base;</span><br><span class="line">    nb = ms-&gt;pending[i+<span class="number">1</span>].len;</span><br><span class="line">    assert(na &gt; <span class="number">0</span> &amp;&amp; nb &gt; <span class="number">0</span>);</span><br><span class="line">    assert(ssa.keys + na == ssb.keys);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Record the length of the combined runs; if i is the 3rd-last</span></span><br><span class="line"><span class="comment">     * run now, also slide over the last run (which isn't involved</span></span><br><span class="line"><span class="comment">     * in this merge).  The current run i+1 goes away in any case.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ms-&gt;pending[i].len = na + nb;</span><br><span class="line">    <span class="keyword">if</span> (i == ms-&gt;n - <span class="number">3</span>)</span><br><span class="line">        ms-&gt;pending[i+<span class="number">1</span>] = ms-&gt;pending[i+<span class="number">2</span>];</span><br><span class="line">    --ms-&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Where does b start in a?  Elements in a before that can be</span></span><br><span class="line"><span class="comment">     * ignored (already in place).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    k = gallop_right(ms, *ssb.keys, ssa.keys, na, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    sortslice_advance(&amp;ssa, k);</span><br><span class="line">    na -= k;</span><br><span class="line">    <span class="keyword">if</span> (na == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Where does a end in b?  Elements in b after that can be</span></span><br><span class="line"><span class="comment">     * ignored (already in place).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    nb = gallop_left(ms, ssa.keys[na<span class="number">-1</span>], ssb.keys, nb, nb<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (nb &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> nb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Merge what remains of the runs, using a temp array with</span></span><br><span class="line"><span class="comment">     * min(na, nb) elements.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (na &lt;= nb)</span><br><span class="line">        <span class="keyword">return</span> merge_lo(ms, ssa, na, ssb, nb);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> merge_hi(ms, ssa, na, ssb, nb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>merge_at</code>函数实现了一个很重要的逻辑，就是把两个相邻的run之间相对排序结果已经排好序的部分剔除掉，把没有排好序的部分放到<code>merge_lo</code>或者<code>merge_hi</code>里进行merge，这又是一个针对大体有序的数组的优化。时间复杂度上，这一逻辑减少了比较和拷贝的次数；空间复杂度上，这一逻辑也减少了在进行merge时需要的辅助空间。把底层设施都写好以后，这个函数看起来十分畅快。先通过gallop确定已经排好序的数组的边界，然后依据数组大小<code>merge_lo</code>或者<code>merge_hi</code>即可。</p>
<h2 id="Collapse-多米诺骨牌"><a href="#Collapse-多米诺骨牌" class="headerlink" title="Collapse-多米诺骨牌"></a>Collapse-多米诺骨牌</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/* Examine the stack of runs waiting to be merged, merging adjacent runs</span><br><span class="line"> * until the stack invariants are re-establish<span class="symbol">ed:</span></span><br><span class="line"> *</span><br><span class="line"> * <span class="number">1</span>. <span class="built_in">len</span>[-<span class="number">3</span>] &gt; <span class="built_in">len</span>[-<span class="number">2</span>] + <span class="built_in">len</span>[-<span class="number">1</span>]</span><br><span class="line"> * <span class="number">2</span>. <span class="built_in">len</span>[-<span class="number">2</span>] &gt; <span class="built_in">len</span>[-<span class="number">1</span>]</span><br><span class="line"> *</span><br><span class="line"> * See listsort.txt for more info.</span><br><span class="line"> *</span><br><span class="line"> * Returns <span class="number">0</span> on success, -<span class="number">1</span> on error.</span><br><span class="line"> */</span><br><span class="line">static <span class="built_in">int</span></span><br><span class="line">merge_collapse(MergeState *ms)</span><br><span class="line">&#123;</span><br><span class="line">    struct s_slice *p = ms-&gt;pending;</span><br><span class="line"></span><br><span class="line">    assert(ms);</span><br><span class="line">    while (ms-&gt;<span class="built_in">n</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        Py_ssize_t <span class="built_in">n</span> = ms-&gt;<span class="built_in">n</span> - <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">if</span> ((<span class="built_in">n</span> &gt; <span class="number">0</span> &amp;&amp; p[<span class="built_in">n</span>-<span class="number">1</span>].<span class="built_in">len</span> &lt;= p[<span class="built_in">n</span>].<span class="built_in">len</span> + p[<span class="built_in">n</span>+<span class="number">1</span>].<span class="built_in">len</span>) ||</span><br><span class="line">            (<span class="built_in">n</span> &gt; <span class="number">1</span> &amp;&amp; p[<span class="built_in">n</span>-<span class="number">2</span>].<span class="built_in">len</span> &lt;= p[<span class="built_in">n</span>-<span class="number">1</span>].<span class="built_in">len</span> + p[<span class="built_in">n</span>].<span class="built_in">len</span>)) &#123;</span><br><span class="line">            <span class="built_in">if</span> (p[<span class="built_in">n</span>-<span class="number">1</span>].<span class="built_in">len</span> &lt; p[<span class="built_in">n</span>+<span class="number">1</span>].<span class="built_in">len</span>)</span><br><span class="line">                --<span class="built_in">n</span>;</span><br><span class="line">            <span class="built_in">if</span> (merge_at(ms, <span class="built_in">n</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                return -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        else <span class="built_in">if</span> (p[<span class="built_in">n</span>].<span class="built_in">len</span> &lt;= p[<span class="built_in">n</span>+<span class="number">1</span>].<span class="built_in">len</span>) &#123;</span><br><span class="line">            <span class="built_in">if</span> (merge_at(ms, <span class="built_in">n</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                return -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Regardless of invariants, merge all runs on the stack until only one</span><br><span class="line"> * remains.  This is used at the end of the mergesort.</span><br><span class="line"> *</span><br><span class="line"> * Returns <span class="number">0</span> on success, -<span class="number">1</span> on error.</span><br><span class="line"> */</span><br><span class="line">static <span class="built_in">int</span></span><br><span class="line">merge_force_collapse(MergeState *ms)</span><br><span class="line">&#123;</span><br><span class="line">    struct s_slice *p = ms-&gt;pending;</span><br><span class="line"></span><br><span class="line">    assert(ms);</span><br><span class="line">    while (ms-&gt;<span class="built_in">n</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        Py_ssize_t <span class="built_in">n</span> = ms-&gt;<span class="built_in">n</span> - <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">if</span> (<span class="built_in">n</span> &gt; <span class="number">0</span> &amp;&amp; p[<span class="built_in">n</span>-<span class="number">1</span>].<span class="built_in">len</span> &lt; p[<span class="built_in">n</span>+<span class="number">1</span>].<span class="built_in">len</span>)</span><br><span class="line">            --<span class="built_in">n</span>;</span><br><span class="line">        <span class="built_in">if</span> (merge_at(ms, <span class="built_in">n</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            return -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这代码也看得爽啊，原来费劲心机写了那么多函数，现在通通拿来把栈中的run给collapse掉完成排序。注意<code>merge_collapse</code>原来是有bug的，不能只比较栈顶前三个元素是否满足collapse条件，还需要检查第四个。见<a href="https://github.com/python/cpython/commit/b808d590a24066bc03d21b55ed5e890a012477a8" target="_blank" rel="noopener">这个commit</a>。</p>
<h2 id="落幕"><a href="#落幕" class="headerlink" title="落幕"></a>落幕</h2><p>至此Timsort的精华部分基本就结束了，以下更多的都是一些简单的问题或者是工程问题。首先是一些简单的工具函数。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Compute a good value for the minimum run length; natural runs shorter</span></span><br><span class="line"><span class="comment"> * than this are boosted artificially via binary insertion.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If n &lt; 64, return n (it's too small to bother with fancy stuff).</span></span><br><span class="line"><span class="comment"> * Else if n is an exact power of 2, return 32.</span></span><br><span class="line"><span class="comment"> * Else return an int k, 32 &lt;= k &lt;= 64, such that n/k is close to, but</span></span><br><span class="line"><span class="comment"> * strictly less than, an exact power of 2.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See listsort.txt for more info.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> Py_ssize_t</span><br><span class="line">merge_compute_minrun(Py_ssize_t n)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t r = <span class="number">0</span>;           <span class="comment">/* becomes 1 if any 1 bits are shifted off */</span></span><br><span class="line"></span><br><span class="line">    assert(n &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= <span class="number">64</span>) &#123;</span><br><span class="line">        r |= n &amp; <span class="number">1</span>;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n + r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void</span><br><span class="line">reverse_sortslice(sortslice *s, Py_ssize_t n)</span><br><span class="line">&#123;</span><br><span class="line">    reverse_slice(s-&gt;keys, &amp;s-&gt;keys[n]);</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;values != <span class="keyword">NULL</span>)</span><br><span class="line">        reverse_slice(s-&gt;values, &amp;s-&gt;values[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于<code>minrun</code>的注释非常清晰。接下来的代码包含了许多比较函数，不是本文重点，我们直接进入sort函数：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* An adaptive, stable, natural mergesort.  See listsort.txt.</span></span><br><span class="line"><span class="comment"> * Returns Py_None on success, NULL on error.  Even in case of error, the</span></span><br><span class="line"><span class="comment"> * list will be some permutation of its input state (nothing is lost or</span></span><br><span class="line"><span class="comment"> * duplicated).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*[clinic input]</span></span><br><span class="line"><span class="comment">list.sort</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    key as keyfunc: object = None</span></span><br><span class="line"><span class="comment">    reverse: bool(accept=&#123;int&#125;) = False</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Stable sort *IN PLACE*.</span></span><br><span class="line"><span class="comment">[clinic start generated code]*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">list_sort_impl(PyListObject *<span class="keyword">self</span>, PyObject *keyfunc, <span class="keyword">int</span> reverse)</span><br><span class="line"><span class="comment">/*[clinic end generated code: output=57b9f9c5e23fbe42 input=b0fcf743982c5b90]*/</span></span><br><span class="line">&#123;</span><br><span class="line">    MergeState ms;</span><br><span class="line">    Py_ssize_t nremaining;</span><br><span class="line">    Py_ssize_t minrun;</span><br><span class="line">    sortslice lo;</span><br><span class="line">    Py_ssize_t saved_ob_size, saved_allocated;</span><br><span class="line">    PyObject **saved_ob_item;</span><br><span class="line">    PyObject **final_ob_item;</span><br><span class="line">    PyObject *result = <span class="keyword">NULL</span>;            <span class="comment">/* guilty until proved innocent */</span></span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    PyObject **keys;</span><br><span class="line"></span><br><span class="line">    assert(<span class="keyword">self</span> != <span class="keyword">NULL</span>);</span><br><span class="line">    assert(PyList_Check(<span class="keyword">self</span>));</span><br><span class="line">    <span class="keyword">if</span> (keyfunc == Py_None)</span><br><span class="line">        keyfunc = <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The list is temporarily made empty, so that mutations performed</span></span><br><span class="line"><span class="comment">     * by comparison functions can't affect the slice of memory we're</span></span><br><span class="line"><span class="comment">     * sorting (allowing mutations during sorting is a core-dump</span></span><br><span class="line"><span class="comment">     * factory, since ob_item may change).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    saved_ob_size = Py_SIZE(<span class="keyword">self</span>);</span><br><span class="line">    saved_ob_item = <span class="keyword">self</span>-&gt;ob_item;</span><br><span class="line">    saved_allocated = <span class="keyword">self</span>-&gt;allocated;</span><br><span class="line">    Py_SIZE(<span class="keyword">self</span>) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">self</span>-&gt;ob_item = <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">self</span>-&gt;allocated = <span class="number">-1</span>; <span class="comment">/* any operation will reset it to &gt;= 0 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (keyfunc == <span class="keyword">NULL</span>) &#123;</span><br><span class="line">        keys = <span class="keyword">NULL</span>;</span><br><span class="line">        lo.keys = saved_ob_item;</span><br><span class="line">        lo.values = <span class="keyword">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (saved_ob_size &lt; MERGESTATE_TEMP_SIZE/<span class="number">2</span>)</span><br><span class="line">            <span class="comment">/* Leverage stack space we allocated but won't otherwise use */</span></span><br><span class="line">            keys = &amp;ms.temparray[saved_ob_size+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            keys = PyMem_MALLOC(sizeof(PyObject *) * saved_ob_size);</span><br><span class="line">            <span class="keyword">if</span> (keys == <span class="keyword">NULL</span>) &#123;</span><br><span class="line">                PyErr_NoMemory();</span><br><span class="line">                <span class="keyword">goto</span> keyfunc_fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; saved_ob_size ; i++) &#123;</span><br><span class="line">            keys[i] = PyObject_CallFunctionObjArgs(keyfunc, saved_ob_item[i],</span><br><span class="line">                                                   <span class="keyword">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (keys[i] == <span class="keyword">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (i=i<span class="number">-1</span> ; i&gt;=<span class="number">0</span> ; i--)</span><br><span class="line">                    Py_DECREF(keys[i]);</span><br><span class="line">                <span class="keyword">if</span> (saved_ob_size &gt;= MERGESTATE_TEMP_SIZE/<span class="number">2</span>)</span><br><span class="line">                    PyMem_FREE(keys);</span><br><span class="line">                <span class="keyword">goto</span> keyfunc_fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lo.keys = keys;</span><br><span class="line">        lo.values = saved_ob_item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The pre-sort check: here's where we decide which compare function to use.</span></span><br><span class="line"><span class="comment">     * How much optimization is safe? We test for homogeneity with respect to</span></span><br><span class="line"><span class="comment">     * several properties that are expensive to check at compare-time, and</span></span><br><span class="line"><span class="comment">     * set ms appropriately. */</span></span><br><span class="line">    <span class="keyword">if</span> (saved_ob_size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        @@@@@@  WEITANGLI: OMMITED  @@@@@@</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* End of pre-sort check: ms is now set properly! */</span></span><br><span class="line"></span><br><span class="line">    merge_init(&amp;ms, saved_ob_size, keys != <span class="keyword">NULL</span>);</span><br><span class="line"></span><br><span class="line">    nremaining = saved_ob_size;</span><br><span class="line">    <span class="keyword">if</span> (nremaining &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">goto</span> succeed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reverse sort stability achieved by initially reversing the list,</span></span><br><span class="line"><span class="comment">    applying a stable forward sort, then reversing the final result. */</span></span><br><span class="line">    <span class="keyword">if</span> (reverse) &#123;</span><br><span class="line">        <span class="keyword">if</span> (keys != <span class="keyword">NULL</span>)</span><br><span class="line">            reverse_slice(&amp;keys[<span class="number">0</span>], &amp;keys[saved_ob_size]);</span><br><span class="line">        reverse_slice(&amp;saved_ob_item[<span class="number">0</span>], &amp;saved_ob_item[saved_ob_size]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* March over the array once, left to right, finding natural runs,</span></span><br><span class="line"><span class="comment">     * and extending short natural runs to minrun elements.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    minrun = merge_compute_minrun(nremaining);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> descending;</span><br><span class="line">        Py_ssize_t n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Identify next run. */</span></span><br><span class="line">        n = count_run(&amp;ms, lo.keys, lo.keys + nremaining, &amp;descending);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        <span class="keyword">if</span> (descending)</span><br><span class="line">            reverse_sortslice(&amp;lo, n);</span><br><span class="line">        <span class="comment">/* If short, extend to min(minrun, nremaining). */</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; minrun) &#123;</span><br><span class="line">            <span class="keyword">const</span> Py_ssize_t force = nremaining &lt;= minrun ?</span><br><span class="line">                              nremaining : minrun;</span><br><span class="line">            <span class="keyword">if</span> (binarysort(&amp;ms, lo, lo.keys + force, lo.keys + n) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">            n = force;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Push run onto pending-runs stack, and maybe merge. */</span></span><br><span class="line">        assert(ms.n &lt; MAX_MERGE_PENDING);</span><br><span class="line">        ms.pending[ms.n].base = lo;</span><br><span class="line">        ms.pending[ms.n].len = n;</span><br><span class="line">        ++ms.n;</span><br><span class="line">        <span class="keyword">if</span> (merge_collapse(&amp;ms) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        <span class="comment">/* Advance to find next run. */</span></span><br><span class="line">        sortslice_advance(&amp;lo, n);</span><br><span class="line">        nremaining -= n;</span><br><span class="line">    &#125; <span class="keyword">while</span> (nremaining);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (merge_force_collapse(&amp;ms) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    assert(ms.n == <span class="number">1</span>);</span><br><span class="line">    assert(keys == <span class="keyword">NULL</span></span><br><span class="line">           ? ms.pending[<span class="number">0</span>].base.keys == saved_ob_item</span><br><span class="line">           : ms.pending[<span class="number">0</span>].base.keys == &amp;keys[<span class="number">0</span>]);</span><br><span class="line">    assert(ms.pending[<span class="number">0</span>].len == saved_ob_size);</span><br><span class="line">    lo = ms.pending[<span class="number">0</span>].base;</span><br><span class="line"></span><br><span class="line">succeed:</span><br><span class="line">    result = Py_None;</span><br><span class="line">fail:</span><br><span class="line">    <span class="keyword">if</span> (keys != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; saved_ob_size; i++)</span><br><span class="line">            Py_DECREF(keys[i]);</span><br><span class="line">        <span class="keyword">if</span> (saved_ob_size &gt;= MERGESTATE_TEMP_SIZE/<span class="number">2</span>)</span><br><span class="line">            PyMem_FREE(keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;allocated != <span class="number">-1</span> &amp;&amp; result != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* The user mucked with the list during the sort,</span></span><br><span class="line"><span class="comment">         * and we don't already have another error to report.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        PyErr_SetString(PyExc_ValueError, <span class="string">"list modified during sort"</span>);</span><br><span class="line">        result = <span class="keyword">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reverse &amp;&amp; saved_ob_size &gt; <span class="number">1</span>)</span><br><span class="line">        reverse_slice(saved_ob_item, saved_ob_item + saved_ob_size);</span><br><span class="line"></span><br><span class="line">    merge_freemem(&amp;ms);</span><br><span class="line"></span><br><span class="line">keyfunc_fail:</span><br><span class="line">    final_ob_item = <span class="keyword">self</span>-&gt;ob_item;</span><br><span class="line">    i = Py_SIZE(<span class="keyword">self</span>);</span><br><span class="line">    Py_SIZE(<span class="keyword">self</span>) = saved_ob_size;</span><br><span class="line">    <span class="keyword">self</span>-&gt;ob_item = saved_ob_item;</span><br><span class="line">    <span class="keyword">self</span>-&gt;allocated = saved_allocated;</span><br><span class="line">    <span class="keyword">if</span> (final_ob_item != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* we cannot use _list_clear() for this because it does not</span></span><br><span class="line"><span class="comment">           guarantee that the list is really empty when it returns */</span></span><br><span class="line">        <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Py_XDECREF(final_ob_item[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        PyMem_FREE(final_ob_item);</span><br><span class="line">    &#125;</span><br><span class="line">    Py_XINCREF(result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数看了也是让人痛心疾首，怎么sort的overhead会这么大。这个函数首先把原先的list置为空来防止在排序中有人改变item的值，然后检查是否调用者指定了<code>key_func</code>即<code>key</code>，如果有则要按之前介绍的那样先把<code>key</code>计算出来，把list里原来存的东西当做<code>value</code>，这里因为相当于凭空多了一个数组所以要进行内存的分配。之后进行的比较函数的选择我们略去。再然后是对<code>reverse</code>这个参数的处理，即实现从大到小排序。粗看起来好像把结果逆序就行了，其实不然，因为我们要的是一个稳定的算法。所以这里要先把未排序数组逆序，然后在排序完成后再进行逆序才可以。<br>之后才正式进入排序，熟悉Timsort的话这一段就很好懂，无非就是一个run一个run的进栈，然后不断collapse就好了。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>综合来看，Timsort其实也算不上多么艰深复杂的算法——基本上是在mergesort的基础上针对有序数组做了一些优化。然而Tim毕竟是第一个把鸡蛋立起来的人，而且其中很多细节处理其实并不容易。<br>Timsort优化主要基础是依据数组的有序片段划分mergesort中各个子merge，把有序的放在一个run里。这样做可能带来一些问题，比如怎样快速选取下一对run进行merge来保证每次merge的两组run长度大体相似（如果相差悬殊则效率很低退化至插入排序），但Tim通过精巧地设定初始run的最小长度和一个栈解决了。<br>关于gallop的优化最根本的出发点是减少对数组中元素比较的次数——正如我们看到的，对于Python来说对元素进行比较是很昂贵的操作。因此，如果比较的成本并不高的话Timsort中关于gallop的部分其实意义不是非常大。然而在实际工作中，对数组元素进行比较成本高昂的情况其实是广泛存在的，最简单直接的例子就是字符串的排序，因此gallop模式的应用场景仍然广阔。<br>有关gallop的优化对于一般的mergesort理论上也适用，但是mergesort可能通过粗暴的划分方式（中点）把数据原本的有序性破坏掉了，因此效果估计会比Timsort当中差。<br>此外，将gallop作为二分查找的变种很值得借鉴。</p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/10/25/mergesort/" rel="next" title="NumPy源码阅读——归并排序">
                <i class="fa fa-chevron-left"></i> NumPy源码阅读——归并排序
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/10/31/travis-debug/" rel="prev" title="本地调试Travis-CI错误">
                本地调试Travis-CI错误 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Weitang Li</p>
              <p class="site-description motion-element" itemprop="description">Weitang Li's blog</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">34</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/liwt31" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:liwt31@163.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#准备工作"><span class="nav-number">1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二分插入排序"><span class="nav-number">2.</span> <span class="nav-text">二分插入排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#山雨欲来风满楼"><span class="nav-number">3.</span> <span class="nav-text">山雨欲来风满楼</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Gallop"><span class="nav-number">4.</span> <span class="nav-text">Gallop!</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Merge的基础设施"><span class="nav-number">5.</span> <span class="nav-text">Merge的基础设施</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#merge-阴阳太极"><span class="nav-number">6.</span> <span class="nav-text">merge-阴阳太极</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collapse-多米诺骨牌"><span class="nav-number">7.</span> <span class="nav-text">Collapse-多米诺骨牌</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#落幕"><span class="nav-number">8.</span> <span class="nav-text">落幕</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结语"><span class="nav-number">9.</span> <span class="nav-text">结语</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Weitang Li</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.4.4</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Mist</a> v6.4.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  










  





  

  

  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    
  


  
  

  

  

  

  

  

</body>
</html>
